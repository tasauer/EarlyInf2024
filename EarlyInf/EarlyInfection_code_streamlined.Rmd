---
title: "EarlyInf_code_2026"
output: html_document
date: "2026-02-12"
---

Code for cleaning, analysis, and visualization of early infection field experiment 2024. 

Load in libraries. 
```{r, load_packages}
library(dplyr)
library(tidyr)
library(ggplot2)
# install.packages("devtools")
#devtools::install_github("davidsjoberg/ggsankey")
library(networkD3)
library(ggsankey)
library(ggpubr)
library(purrr)
library(ggsankey)
library(readr)
library(stringr)
library(scales)
library(purrr)
library(gridExtra)
library(grid)
```

Set working directory manually through RStudio, then verify and read in files. 
```{r, read_in_files}
#check working directory
getwd()

#read in data
raw_data <- read_csv("Data/latent_inf_2024.csv", show_col_types = FALSE)
#View(raw_data)
```

Change to long format. This collapses all checks to an "infection status" column 
```{r, long_format}
#need to rename death_date column
colnames(raw_data)[colnames(raw_data) == "Death_date"] <- "Mortality_date"
colnames(raw_data)[colnames(raw_data) == "D0_infstatus"] <- "D0_INFSTATUS"

long_data <- raw_data %>%
  pivot_longer(
    cols = starts_with("D"),  # Select only the columns to reshape
    names_to = c("day_check", ".value"),
    names_pattern = "(D[0-9]+)_(.+)"
  )

head(long_data)

#make a new column for check number integer
long_data$check <- as.numeric(gsub("\\D", "", long_data$day_check))
```

Clean data by making everything lowercase and checking that each infection type only has 1 unique ID

```{r, clean_IDs}

#check unique names of lakes 
unique(long_data$Lake)

#Sullivan is mispelled in at least one round. Fix this 
long_data <- long_data %>% 
mutate(Lake = case_when(
        Lake %in% "Sullvian" ~ "Sullivan"
        ,TRUE ~ Lake
        )
    )
#change crooked_w to crooked 
long_data <- long_data %>% 
mutate(Lake = case_when(
        Lake %in% "Crooked_W" ~ "Crooked"
        ,TRUE ~ Lake
        )
    )

#make all infection statues lowercase so coding is easier later on
long_data$INFSTATUS <- tolower(long_data$INFSTATUS)

#id all unique infection IDs to see which have to be changed
unique(long_data$INFSTATUS)

#Sus gut is not a real classification, so I am going to change it to uninfected
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% "sus_gut" ~ "u"
        ,TRUE ~ INFSTATUS
        )
    )
#"S" is meant to be sprite, change to sprite
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% "s" ~ "sprite"
        ,TRUE ~ INFSTATUS
        )
    )
#make red into "spiro"
#NOTE Feb 2026: I am removing white spiro from the spiro definition because we can't definitively say white spiro is spiro
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% c("red_spiro") ~ "spiro"
        ,TRUE ~ INFSTATUS
        )
    )
#make all sprite & spiro coinfections uniform
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% c("sprite_red_spiro") ~ "sprite_spiro"
        ,TRUE ~ INFSTATUS
        )
    )
#Switch all unknowns to unk

#make all sprite & spiro coinfections uniform
#Feb 2026: Change white spiro to an unknown
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% c("white_spiro", "unk_beady", "unk_spider", "unk_p/s", "unk_cloudy") ~ "unk"
        ,TRUE ~ INFSTATUS
        )
    )

#turn sprite coinfection with white spiro to sprite_unk
long_data <- long_data %>% 
mutate(INFSTATUS = case_when(
        INFSTATUS %in% c("sprite_white_spiro") ~ "sprite_unk"
        ,TRUE ~ INFSTATUS
        )
    )

#check all unique ids again
unique(long_data$INFSTATUS)

#rename columns to make coding easier
colnames(long_data) <- gsub(" ", "_", colnames(long_data))

```


###################################
Tile & Sankey Plot figures
###################################

This section is code for the tile and sankey plots which illustrate the raw data and how we determined "early stage" infections.

Prior to running through all lakes and rounds to generate these plots, we need to change infection status names to abbreviations for the manuscript. These abbreviations will be used for all of the figures
```{r}
#create a copy of the data frame to adjust for plots
p_data <-long_data

#now we need to change the values in this dataset to have the abbreviations appropriate for the manuscript
unique(p_data$INFSTATUS)

p_data <- p_data %>%
  mutate(INFSTATUS = case_when(
    INFSTATUS == "u" ~ "Uninfected",
    INFSTATUS == "dead" ~ "Dead",
    INFSTATUS == "micg" ~ "OP",
    INFSTATUS == "past" ~ "PR",
    INFSTATUS == "micg_past" ~ "OP&PR",
    INFSTATUS == "sprite" ~ "PP",
    INFSTATUS == "sprite_spiro" ~ "PP&SC",
    INFSTATUS == "spiro" ~ "SC",
    INFSTATUS == "unk" ~ "Unk",
    INFSTATUS == "sprite_micg" ~ "PP&OP",
    INFSTATUS == "brood" ~ "BP",
    INFSTATUS == "metsch" ~ "AM",
    INFSTATUS == "micg_unk_p/s" ~ "OP&Unk",
    INFSTATUS == "sprite_brood" ~ "PP&BP",
    INFSTATUS == "sprite_past" ~ "PP&PR",
    INFSTATUS == "sprite_metsch" ~ "PP&AM",
    INFSTATUS == "sprite_unk" ~ "PP&Unk",
    TRUE ~ INFSTATUS
  ))

#verify changes
unique(p_data$INFSTATUS)
```
Create a unique color palette for tile & sankey plots

```{r, try_tile_plots}

unique(long_data$INFSTATUS)
##custom color palette for these data
color_palette_all <- c("Uninfected" = "springgreen", "SC" = "brown1", "OP" = "darkgoldenrod1",
                   "PP"="chocolate1", "BP"="deeppink", 
                   "PR"= "darkorchid1", "AM"="cadetblue1", "Unk"="gray50",
                   "PP&BP"= "deeppink4", "PP&SC"="brown4",
                   "PP&PR"="darkorchid4", "PP&AM"="cadetblue4",
                   "PP&OP"="darkgoldenrod4","OP&PR"="deeppink3", "OP&Unk"="gray40",
                   "PP&Unk"="gray60",
                   "Dead"="black")


#below is color palette for unedited infection status names 
color_palette_all_uneditednames <- c("u" = "springgreen", "spiro" = "brown1", "micg" = "darkgoldenrod1",
                   "sprite"="chocolate1", "brood"="deeppink", 
                   "past"= "darkorchid1", "metsch"="cadetblue1", "unk"="gray50",
                   "sprite_brood"= "deeppink4", "sprite_spiro"="brown4",
                   "sprite_past"="darkorchid4", "sprite_metsch"="cadetblue4",
                   "sprite_micg"="darkgoldenrod4","micg_past"="deeppink3", "micg_unk_p/s"="gray40",
                   "sprite_unk"="gray60",
                   "dead"="black")


#Reorder the levels of infection status to look better on the sankey plots/legends
#potentially reorder the factor levels so that it looks better for legend and for sankey plot purposes
p_data <- p_data %>%
  mutate(INFSTATUS = factor(INFSTATUS, levels = c("Uninfected",
                                                    "AM","BP","OP","OP&PR","PP",
                                                    "PP&AM","PP&BP","PP&OP",
                                                    "PP&PR","PP&SC","PR","SC",
                                                    "OP&Unk","PP&Unk","Unk","Dead")))

#repeat this leveling as an independent vector; this will have to be used in the sankey plot separately since the data is reorganized in order to generate the plot
#update: for reasons unknown to me the above vector must be reversed exactly in order for sankey levels to make sense. 
custom_levels <- c("Dead", "Unk", "PP&Unk", "OP&Unk",
                                                  "SC", "PR", "PP&SC", "PP&PR",
                                                  "PP&OP","PP&BP","PP&AM",
                                                  "PP","OP&PR", "OP","BP","AM",
                                                  "Uninfected")

 
#rename day_check so that node lables look better
p_data <- p_data %>%
  mutate(day_check = case_when(
    day_check == "D0" ~ "Day0",
    day_check == "D1" ~ "Day1",
    day_check == "D4" ~ "Day4",
    day_check == "D8" ~ "Day8",
    day_check == "D11" ~ "Day11",
    day_check == "D15" ~ "Day15",
    TRUE ~ day_check
  ))

```

Iterate through all rounds & lakes to create tileplots tracking each individual's infection status over monitoring period. 
```{r, tile_plots_loop}

# Create named vector for lake identifiers
lake_ids <- c(
  "Cedar" = "c",
  "Bishop" = "b",
  "Walsh" = "w",
  "Crooked" = "cw",
  "Sullivan" = "s",
  "Mill" = "m"
)

# Get unique lakes
unique_lakes <- unique(p_data$Lake)

#FOR LOOP FOR LOOP FOR LOOP
for (lake in unique_lakes) {
  
  lake_data <- p_data[p_data$Lake == lake, ]
  rounds <- unique(lake_data$Round)
  
  #get lake unique ID
  lake_id <- lake_ids[[lake]]
  
  # Create tile plots for each round
  lake_tiles <- lapply(rounds, function(round) {
    
    round_data <- lake_data[lake_data$Round == round, ]
    
    ggplot(round_data, aes(x = as.factor(check), y = Animal_ID)) +
      geom_tile(aes(fill = INFSTATUS), color = "grey20") +
      scale_fill_manual(values = color_palette_all, name = "Infection Status") +
      labs(
        x = "Days after field collection",
        y = "",
        title = ""
      ) +
      theme_minimal() +
      theme(axis.text.y = element_blank(),
            legend.position = "none")
  })
  
  # Assign each plot a unique name 
  for (i in seq_along(lake_tiles)) {
    assign(
      paste0("tileplot_", lake_id, rounds[i]),
      lake_tiles[[i]]
    )
  }
}

# Check objects created
ls(pattern = "tileplot_")

#check a random plot to verify that it worked 
tileplot_b1
```

Do the same with Sankey plots, iterating through all lakes and rounds
```{r, sankey_plot_loop}
# Loop through each lake
#FOR LOOP FOR LOOP FOR LOOP
for (lake in unique_lakes) {
  
  lake_data <- p_data[p_data$Lake == lake,
                         c("Animal_ID", "Round", "Lake", "day_check", "INFSTATUS")]
  
  rounds <- unique(lake_data$Round)
  
  lake_id <- lake_ids[[lake]]
  
  # Create sankey plots for each round
  lake_sankeyplots <- lapply(rounds, function(round) {
    
    round_data <- lake_data[lake_data$Round == round, ]
    
    # #pivot wider so that each check has it's own column where the infection status is the value (like the data input          format)
    data_wide <- pivot_wider(
      round_data,
      names_from = day_check,
      values_from = INFSTATUS
    )
    
    ##use the ggsankey function make_long to make a descriptive dataframe that ggsankey can use
    sankey_df <- data_wide %>%
      make_long(Day0, Day1, Day4, Day8, Day11, Day15)
    
    #reorder the factor levels in the sankey plot
    #reorder the factor levels using the custom vector made in one of the earlier chunks
    sankey_df <- sankey_df %>%
         mutate(
         node = factor(node, levels = custom_levels),
         next_node = factor(next_node, levels = custom_levels)
       )
    
    #this is the actual plot for sankey plots
    ggplot(
      sankey_df,
      aes(
        x = x,
        next_x = next_x,
        node = node,
        next_node = next_node,
        label=node,
        fill = factor(node)
      )
    ) +
      geom_sankey(
        flow.alpha = .6,
        node.color = "gray30",
        na.rm = TRUE
      ) +
      geom_sankey_label(
        size = 5,
        color = "white",
        fill = "gray30"
      ) +
      theme_sankey(base_size = 18) +
      scale_fill_manual(values = color_palette_all) +
      labs(
        x = NULL,
        title = ""
      ) +
      theme(
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        legend.key.size = unit(0.6, "cm"),
      )
  })
  
  # Assign names using lake short IDs
  for (i in seq_along(lake_sankeyplots)) {
    assign(
      paste0("sankey_", lake_id, rounds[i]),
      lake_sankeyplots[[i]]
    )
  }
}

# Check created objects
ls(pattern = "sankey_")

#look at a random sankey to check
sankey_s7 #DONT WORRY I KNOW THE LABELS LOOK CRAZY DON'T EVEN WORRY
```
Now we have named plots that should be arranged and saved into the figures folder. Given the uniform format across all the plot names, I can call them in a loop to iterate through all lakes and rounds once again.
```{r, arrange_tiles_sankeys}
#FOR LOOP FOR LOOP FOR LOOP
#first generate a vector for the loop to use of all the unique names
lake_codes <- c("c", "b", "w", "m", "cw", "s")
nums  <- 1:9

lake_round_vec<- with(expand.grid(code = lake_codes, num = nums),
                  paste0(code, num))


#For loop time
#warning this one takes a long time!!
for (i in lake_round_vec) {
  
  sankey_name   <- paste0("sankey_", i)
  tileplot_name <- paste0("tileplot_", i)
  
  #we should only be attempting such things if both sankey and tileplot exist 
  if (exists(sankey_name) && exists(tileplot_name)) {
    
    sankey   <- get(sankey_name)
    tileplot <- get(tileplot_name)
    
    p_combined <- ggarrange(tileplot, sankey,
                            common.legend = FALSE,
                            widths = c(1,3))
    
    #create a file name using the iterated value, nest in appropriate folder
    file_name <- paste0("Figures/methods_plots/", i, "_methods_figure.png")
    
    #save using file name 
    ggsave(file_name,
           p_combined,
           width = 12, height = 8, dpi = 400, bg = "white")
  }
}

```

Two representative plots from this selection will make it into the main body of the manuscript: a simple round and a more complicated round. The rest will either perish here or be put into the supplementary.

###################################
Summary Calculations & Figures
###################################

Now I'm going to try to make summary graphs. I think the way to go about this will be to make separate T/F columns in the wide data to scan for each parasite. So there will be a "micg inf" column, and a "metsch" column. Then we can determine if they had simultaneous coinfections somehow? With sums >2 of all the infection T/F columns. 

For the summary statistics, as with the field data, I will count co-infections as a "T" count for each individual parasite. So, if there is a micg-sprite infection, it will count as T for presence of infection by both micg and sprite. 

```{r, summarize_dataorganizing}
#for each parasite, create new column in the wide data which scans the check dates and determines if there are any checks with that parasite.

#look at unique infection statuses across all data (using long data again)
unique(long_data$INFSTATUS)


#the long_format data needs to go to wide format again so that each row is one individual
#since we did all data cleaning with the long data format, we need to first compress back to a wide format with the clean data
# we first need to remove the "check column"
long_data_reformattting<- subset(long_data, select = -check )
long_data_reformattting<- subset(long_data_reformattting, select = -date )
#NOTE: Wide data does not have the date attributed to each check
#reformat to wide 
data_wide <- pivot_wider(long_data_reformattting, names_from = day_check, values_from = INFSTATUS)

#create vectors of all the INFSTATUS IDs that indicate infection by one of the parasites, excluding unknown as its' own category

#metsch
Y_metsch <- c("metsch","sprite_metsch")

#past
Y_past <- c("past", "micg_past", "sprite_past")

#brood
Y_brood <- c("brood", "sprite_brood")

#spiro
Y_spiro <- c("spiro", "sprite_spiro")

#micg
Y_micg <- c("micg", "micg_unk_p/s", "micg_past", "sprite_micg")

#sprite
Y_sprite <- c("sprite", "sprite_metsch", "sprite_spiro", "spiro_brood", "sprite_micg",
              "sprite_past", "sprite_unk")

#create a loop vector for all the parasite names
parasites <- c("metsch","past","brood","spiro","micg","sprite")

#FOR LOOOOOOOOOPPPPPP
#we are creating new columns in the wide data to determine if a given individual has a given parasite (giving T/F values)
for(p in parasites){
  
  #assign called parasite to a vector name 
  p_vec <- get(paste0("Y_",p))
  
  #create a T/F column for any animal that had 
  data_wide[[p]] <- apply(data_wide[, c("D0", "D1","D4", "D8","D11","D15")], 1, function(row){
  any(row %in% p_vec)
  })
  }


```
Now, we have to filter the data more to exclude animals who died before we would reasonably be able to say that they STAYED uninfected. To do this, I am going to go back to the main data set, then filter animals which didn't die on day 4.

Then when I summarize the data set I will filter out any rounds which have less than 20 animals left to a round. This is so that future calculations do not show an outsized proportion with infection. 

```{r, subsetting_alldata}
#first, go back to the main data set and create a new column determining if animals died by day 4. 
data_wide$ear_mort <- data_wide$D4=="dead"
sum(data_wide$ear_mort) #the sum of this column is 1170, meaning that roughly a third of animals died on or before day 4 and will not be included in data analyses. :(


#create a new main data frame that has all animals which lived past day 4
filtered_data <-data_wide[data_wide$ear_mort==FALSE,]
```
Summarize data: calculate proportions, create a column for number of individuals used to calculated that proportion
```{r, summarize data}

#use dplyr to summarize data
##call parasite vector used in previous chunk
summary_data_all <- filtered_data %>%
  group_by(Lake, Round) %>%
  summarise(
    total_ind = n(),
    across(all_of(parasites), mean, .names = "proportion_{.col}"),
    .groups = "drop"
  )

#summary_data

#remove proportions wherever there were 20 or less individuals
summary_data <- summary_data_all[summary_data_all$total_ind>20,]


#pivot to long format
sum_data_long <- summary_data %>%
  pivot_longer(
    cols = starts_with("proportion"), 
    names_to = "parasite", 
    values_to = "proportion_li"
  ) %>%
#OK, now all the parasite names include "proportion", so remove that
 mutate(parasite = str_remove(parasite, "^proportion_"))


#make round a factor
sum_data_long$Round <- factor(sum_data_long$Round, levels = unique(sum_data_long$Round))

```

Now we're getting started on summary figures. First start with a preset for future summary figures
```{r, summary_figure_presets}
presets_sum <- theme(panel.grid.minor=element_blank(),
                 panel.grid.major=element_blank(),
                 panel.background=element_rect(fill="transparent", colour = NA),
                 plot.background=element_rect(fill="transparent", colour = NA),
                 #panel.border=element_rect(colour = 'black', fill = NA, linewidth = 0.5),
                 panel.border = element_blank(),
                 axis.line = element_line(color="black"),
                 axis.ticks=element_line(colour = 'black', linewidth = 0.5), 
                 axis.text.x = element_text(family="sans", size=8, color="black"), 
                 axis.text.y = element_text(family="sans", size=8, color="black"),
                 strip.background = element_blank(),
                 strip.text = element_text(family="sans", size=10),
                 plot.title = element_text(hjust = 0.5, vjust=-5, size=10, face="bold"),
                 axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
                 axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)))
```

Summary figures: There are two options, the one I have been doing with lines and the stacked bars 

```{r, summary_figure_option1}

#again, assign abbreviations to parasites
labels_abbrevs<- c("brood"="BP",
                             "metsch"="AM",
                             "micg"="OP",
                             "past"="PR",
                             "spiro"="SC",
                             "sprite"="PP")


#assign abbrevs to the parasites 
summary_fig_data <- sum_data_long %>%
  mutate(parasite = dplyr::recode(parasite, !!!labels_abbrevs))


#rerun the summary proportion latent infection >= 15 animals plot
summary_proportions <- ggplot(summary_fig_data, aes(y = proportion_li, x = Round, color = parasite,
                                              group=parasite)) +
                          geom_line() +
                          geom_point() +
                          facet_wrap(~ Lake, scales = "free_y") +
                          labs(
                            title = "",
                            x = "Round",
                            y = "Proportion",
                            color = "Parasite"
                          ) +
                          scale_color_manual(values=color_palette_all)+
                          theme_minimal() +
                          theme(legend.position = "right")+
                          presets_sum


summary_proportions

ggsave("Figures/summary_proportions.png", plot = summary_proportions, width = 6, height = 4, dpi = 600, bg="white")
```
Option two for this summary data set is stacked bars or something of the  kind; makes it clear that these data are from distinct groups of individuals. This option also makes it easier to see where we did not collect or maintain more than 20 animals and so are not including the calculated proportion.

This is not a complete figure; I really just need feedback on whether this is a better representation of the data. I like the idea of stacked bar graph but also think it gives a false impression of total proportion of individuals presenting an infection given that these individual parasite proportions are calculated using co-infections. 

```{r}

# Compute a scaling factor to align counts with proportions
max_prop <- max(summary_fig_data$proportion_li, na.rm = TRUE)
max_count <- max(summary_fig_data$total_ind, na.rm = TRUE)
scale_factor <- max_prop / max_count  # will scale counts to match proportion height

test_summary_stacked <-ggplot(summary_fig_data, aes(x = Round)) +
  
  # Stacked bar of proportions
  geom_bar(aes(y = proportion_li, fill = parasite), 
           stat = "identity", position = "stack") +
  
  # Overlay total individuals as line
  geom_line(aes(y = total_ind * scale_factor, group = Lake),
            color = "black", size = 1) +
  geom_point(aes(y = total_ind * scale_factor), color = "black", size = 2) +
  
  facet_wrap(~Lake) +
  scale_fill_manual(values=color_palette_all)+
  
 
  # Left y-axis for proportions
  scale_y_continuous(
    name = "Proportion of Infected Individuals",
    labels = percent_format(accuracy = 1),
    # Secondary axis for counts
    sec.axis = sec_axis(~./scale_factor, name = "Number of Individuals")
  ) +
  
  labs(x = "Sampling Round", fill = "Parasite") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 10, face = "bold")
  )+
  presets_sum

test_summary_stacked

```

###################################
Prevalence data & added estimated overall prevalence
###################################

Now that we've calculated proportions of our monitored animals which presented infections of each parasites, we can use those proportions, along with the field prevalence data, to calculate and visualize estimated overall prevalence and estimated overall numbers of infected individuals using areal density. 


Load in prevalence data
```{r, readin_prev_data}
#load in data
prev_data <- read.csv(file="Data/Clean-Data-2014-2024.csv", header=T)
head(prev_data)
unique(prev_data$Lake)

#filter data to just 2024 and dentifera
d2024 <- prev_data[prev_data$Year==2024&prev_data$Host.Species=="dentifera",]

#filter to just the lakes we looked at for this project
unique(d2024$Lake)
prev <- d2024[d2024$Lake=="Walsh"|d2024$Lake=="Mill"|d2024$Lake=="Cedar"|
                d2024$Lake=="CrookedW"|d2024$Lake=="Bishop"|d2024$Lake=="Sullivan",]
unique(prev$Lake)

#change columnlibrary(dplyr)
prev<- rename(prev,
              prev_past = pasteuria.prev, 
              prev_metsch = metsch.prev,
              prev_brood = brood.prev, 
              prev_sprite = coke.prev,
              prev_spiro = spiro.prev, 
              prev_micg = micG.prev,
              n_past = pasteuria.inf, 
              n_metsch = metsch.inf,
              n_brood = brood.inf, 
              n_sprite = coke.inf,
              n_spiro = spiro.inf, 
              n_micg = micG.inf,
              )


```
Ok now I have the prevalence data for all the lakes and dentifera, which includes the counts of the uninfected adults and juveniles separately. My goal is to have the prevalence data for each parasite as well as an edited prevalence for each data point which applies the proportion of animals which had unapparent infections to the overall uninfected count.

```{r, prepping_prevdata}
#create a new column in the prev data set with all the uninfected animals added together
prev$Uninfected.All <- prev$Uninfected.Adult+prev$Uninfected.Ephip+prev$Uninfected.Juv+prev$Uninfected.Males

#now we need to find a way to merge the two data sets
#the prevalence data does not have round number included 
#to add it in, match rounds to julian dates for each lake

prev <- prev %>%
  mutate(
    Round = case_when(
      Julian %in% c(198, 197, 204, 207) ~ 1,
      Julian %in% c(213, 211, 218, 221) ~ 2,
      Julian %in% c(227, 225, 232, 235) ~ 3,
      Julian %in% c(241, 239, 247, 249) ~ 4,
      Julian %in% c(255, 253, 260, 263) ~ 5,
      Julian %in% c(269, 267, 274, 277) ~ 6,
      Julian %in% c(283, 281, 288, 291) ~ 7,
      Julian %in% c(297, 295, 302, 305) ~ 8,
      Julian %in% c(311, 309, 316, 319) ~ 9,
      TRUE ~ NA_integer_  # Optional: handles cases that don't match
    )
  )

#CrookedW is not the same in both data sets so switch it
prev <- prev %>%
  mutate(Lake = case_when(
    Lake == "CrookedW" ~ "Crooked",
    TRUE ~ Lake
  ))
```

Now we're going to use the wide summary data frame. Use the filtered data frame for early infection, and use the full join function to ensure that any missing lakes/rounds in the early infection data are populated with NAs (rather than prevalence data being discarded for those lake/rounds).

```{r}
#join data together
prev_join <- full_join(prev, summary_data, by = c("Lake", "Round"))

#create an empty list to populate
long_prev_list <- list()


#for loop, iterate through all parasites to calculate estimated overall prevalence based on number infected, number uninfected and total number of dentifera in each sample 
for (p in parasites) {
  
  prop_col <- sym(paste0("proportion_", p))
  prev_col <- sym(paste0("prev_", p)) 
  n_inf_col <- sym(paste0("n_",p))
  
  df_tmp <- prev_join %>%
    mutate(
      est_numinf = (!!prop_col * Uninfected.All) + (!!n_inf_col),
      est_overallprev = est_numinf / Total
    ) %>%
    rename(
      !!paste0("visual_", p) := !!prev_col,
      !!paste0("overall_", p) := est_overallprev
    ) %>%
    pivot_longer(
      cols = c(paste0("visual_", p), paste0("overall_", p)),
      names_to = "prevtype",
      values_to = "prev_value"
    ) %>%
    mutate(parasite = p)
  
  long_prev_list[[p]] <- df_tmp
}

# Combine all parasites into one dataframe
long_all_prev <- bind_rows(long_prev_list)


#total number of dentifera observed must be 20 or more; filtering will exclude any case where we didn't count 20 in the field sample but I collected enough to monitor animals using extra tows
long_all_prev <- subset(long_all_prev, Total>=20)
```

Calculate areal density over infected animals. The argument here is that my story in the manuscript is that we are failing to capture infections which may be having ecosystem level effects, yet we are not showing data at ecosystem-level scales. Here we are scaling up the prevalence and estimated overall prevalence data to the areal densities of dentifera in the lake.

```{r}

#using the long format of the data, calculate number of infected animals. Since we are in long format, rows for visible and overall estimated infection are all calculated in this new column 
long_all_prev$areal_infection <- long_all_prev$prev_value*long_all_prev$Host.Density

#take the log of these values
long_all_prev$log_n_inf <- log10(long_all_prev$areal_infection)

#log overall host density as well
long_all_prev$log_all <- log10(long_all_prev$Host.Density)
```

Set figure presets

```{r, figure_presets}
#################
# Figure presets
#################

presets <- theme(panel.grid.minor=element_blank(),
                 panel.grid.major=element_blank(),
                 panel.background=element_rect(fill="transparent", colour = NA),
                 plot.background=element_rect(fill="transparent", colour = NA),
                 #panel.border=element_rect(colour = 'black', fill = NA, linewidth = 0.5),
                 panel.border = element_blank(),
                 axis.line = element_line(color="black"),
                 axis.ticks=element_line(colour = 'black', linewidth = 0.5), 
                 axis.text.x = element_text(family="sans", size=8, color="black"), 
                 axis.text.y = element_text(family="sans", size=8, color="black"),
                 strip.background = element_rect(fill = "gray90", colour = "black", linewidth = 0.5),
                 strip.text = element_text(family="sans", size=12),
                 plot.title = element_text(hjust = 0.5, vjust=-8, size=10, face="bold"),
                 axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
                 axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)))
```

```{r}
#setting up a for loop for generating plots with estimated overall prevalence
#dictace unique colors for each parasite
parasite_colors <- list(
  metsch = c(overall = "#5CACEE", visual = "#cee6fa"),
  past   = c(overall = "#bf3eff", visual = "#ecc5ff"),
  brood  = c(overall = "#ff1293", visual = "#ffb8df"),
  spiro  = c(overall = "#ff4040", visual = "#ffc6c6"),
  micg   = c(overall = "goldenrod", visual = "lightgoldenrod1"),
  sprite = c(overall = "#ff7f24", visual = "#ffd9bd")
)

#determine y limits 
parasite_ylims <- c(
  metsch = 0.075,
  past   = 0.3,
  brood  = 0.075,
  spiro  = 0.1,
  micg   = 0.6,
  sprite = 1.00
)

#parasite titles
parasite_titles <- c(
  metsch = "AM",
  past   = "PR",
  brood  = "BP",
  spiro  = "SC",
  micg   = "OP",
  sprite = "PP"
)

lakenames<-unique(long_all_prev$Lake)
parasites<-unique(long_all_prev$parasite)

#for loop through all parasites and lakes, each generating a named plot in the workspace for later ggarrange magic
for (p in parasites) {
  for (lake in lakenames) {
    
    df_sub <- subset(long_all_prev, Lake == lake & parasite == p)
    if (nrow(df_sub) == 0) next
    
    # assign specific colors for the parasite
    col_overall <- parasite_colors[[p]]["overall"]
    col_visual  <- parasite_colors[[p]]["visual"]
    
    # set unique y limit
    y_max <- parasite_ylims[p]
    
    # create specific title using parasite abbreviations
    title_expr <- bquote(bold(.(lake)) * ": " * italic(.(parasite_titles[[p]])))
    
    p_plot <- ggplot() +
      geom_area(
        data = subset(df_sub, prevtype == paste0("overall_", p)),
        aes(x = Julian, y = prev_value),
        fill = col_overall, col = "black"
      ) +
      geom_area(
        data = subset(df_sub, prevtype == paste0("visual_", p)),
        aes(x = Julian, y = prev_value),
        fill = col_visual, col = "black"
      ) +
      ggtitle(title_expr) +
      xlab("") +
      ylab("") +
      ylim(0, y_max) +
      scale_x_continuous(
        breaks = c(197,218,247,277,309),
        labels = c("Jul","Aug","Sept","Oct","Nov")
      ) +
      presets
    
    assign(paste0(lake, "_", p), p_plot, envir = .GlobalEnv)
  }
}

```
Arrange all plots



```{r, megaplotting}
#first, generate a blank plot that can be inserted for spacing
blank_plot <- ggplot() +
  theme_void()
blank_plot

#try using grid.arrange instead
plot_list <- list(
  Bishop_sprite, Cedar_sprite, Crooked_sprite, Mill_sprite, Sullivan_sprite, Walsh_sprite,
  Bishop_micg, Cedar_micg, Crooked_micg, Mill_micg, Sullivan_micg, Walsh_micg,
  Bishop_past, Cedar_past, Crooked_past, Mill_past, Sullivan_past, Walsh_past,
  Bishop_spiro, Cedar_spiro, Sullivan_spiro, Walsh_spiro, blank_plot, blank_plot,
  Sullivan_metsch, Cedar_brood, Walsh_brood, blank_plot, blank_plot, blank_plot
)

#try to reduce margins across all plots
plot_list <- lapply(plot_list, function(p) {
  p + theme(plot.margin = margin(0.5, 0.5, 0.5, 0.5))  # in points
})


megaplot4 <- grid.arrange(
  arrangeGrob(grobs = plot_list, ncol = 6, nrow = 5),
  left = textGrob("Parasite Prevalence (Proportion Infected)", rot = 90, gp = gpar(fontsize = 14))
)
ggsave("Figures/megaplot_draf.pdf", megaplot4, width = 20, height = 15)
ggsave("Figures/megaplot_draft.png", megaplot4, width = 12, height = 8, dpi=600, bg="white")
```

